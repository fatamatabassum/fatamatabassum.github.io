<script>
  const reduce = window.matchMedia("(prefers-reduced-motion: reduce)").matches;

  const bubbles = Array.from(document.querySelectorAll(".bubble"));
  const prefersHover = window.matchMedia("(hover:hover)").matches;

  function clamp(v,min,max){ return Math.min(max, Math.max(min, v)); }

  // Track pointer
  let px = window.innerWidth/2, py = window.innerHeight/2;
  let rafPending = false;

  function scheduleUpdate(){
    if (rafPending) return;
    rafPending = true;
    requestAnimationFrame(()=>{
      updateDynamics();
      rafPending = false;
    });
  }

  function updateDynamics(){
    const vh = window.innerHeight;
    const vw = window.innerWidth;

    bubbles.forEach(b=>{
      const r = b.getBoundingClientRect();

      // 1) Scroll proximity (0..1): strongest at viewport center (Apple vibe)
      const mid = r.top + r.height/2;
      const dist = Math.abs(mid - vh/2);
      const sp = 1 - clamp(dist / (vh * 0.55), 0, 1); // tune 0.55 for stronger/weaker
      b.style.setProperty("--sp", sp.toFixed(3));

      // 2) Past blur (0..1): smooth as it leaves upward
      // start fading once bottom goes above 35% vh, max near top
      const start = vh * 0.35;
      const end   = vh * 0.05;
      const t = (start - r.bottom) / (start - end);
      const past = clamp(t, 0, 1);
      b.style.setProperty("--past", past.toFixed(3));

      // 3) Mouse refraction: only if bubble is somewhat near viewport + device supports hover
      if (prefersHover) {
        const cx = r.left + r.width/2;
        const cy = r.top + r.height/2;

        // Normalize pointer relative to bubble center (-1..1)
        const mx = clamp((px - cx) / (r.width * 0.55), -1, 1);
        const my = clamp((py - cy) / (r.height * 0.55), -1, 1);

        // Damp if bubble is far away (so offscreen bubbles don’t “react”)
        const damp = clamp(sp + 0.15, 0, 1);
        b.style.setProperty("--mx", (mx * damp).toFixed(3));
        b.style.setProperty("--my", (my * damp).toFixed(3));
      } else {
        b.style.setProperty("--mx", "0");
        b.style.setProperty("--my", "0");
      }
    });
  }

  // Reveal observer stays (if you already have one, keep it)
  if (!reduce) {
    const io = new IntersectionObserver(entries=>{
      entries.forEach(e=>{
        if(e.isIntersecting) e.target.classList.add("is-visible");
      });
    }, { threshold: 0.18, rootMargin: "0px 0px -12% 0px" });

    document.querySelectorAll(".reveal").forEach(el=>io.observe(el));
  } else {
    document.querySelectorAll(".reveal").forEach(el=>el.classList.add("is-visible"));
  }

  if (!reduce) {
    // Pointer
    window.addEventListener("pointermove", (e)=>{
      px = e.clientX; py = e.clientY;
      scheduleUpdate();
    }, { passive:true });

    // Scroll + resize
    window.addEventListener("scroll", scheduleUpdate, { passive:true });
    window.addEventListener("resize", scheduleUpdate, { passive:true });

    // Initial
    updateDynamics();
  }
</script>
